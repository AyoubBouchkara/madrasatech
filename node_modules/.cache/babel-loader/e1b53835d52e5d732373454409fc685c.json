{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nvar _warning = require('warning');\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nvar _historyLibActions = require('history/lib/Actions');\n\nvar _historyLibUseQueries = require('history/lib/useQueries');\n\nvar _historyLibUseQueries2 = _interopRequireDefault(_historyLibUseQueries);\n\nvar _computeChangedRoutes2 = require('./computeChangedRoutes');\n\nvar _computeChangedRoutes3 = _interopRequireDefault(_computeChangedRoutes2);\n\nvar _TransitionUtils = require('./TransitionUtils');\n\nvar _isActive2 = require('./isActive');\n\nvar _isActive3 = _interopRequireDefault(_isActive2);\n\nvar _getComponents = require('./getComponents');\n\nvar _getComponents2 = _interopRequireDefault(_getComponents);\n\nvar _matchRoutes = require('./matchRoutes');\n\nvar _matchRoutes2 = _interopRequireDefault(_matchRoutes);\n\nfunction hasAnyProperties(object) {\n  for (var p in object) {\n    if (object.hasOwnProperty(p)) return true;\n  }\n\n  return false;\n}\n/**\n * Returns a new createHistory function that may be used to create\n * history objects that know about routing.\n *\n * Enhances history objects with the following methods:\n *\n * - listen((error, nextState) => {})\n * - listenBeforeLeavingRoute(route, (nextLocation) => {})\n * - match(location, (error, redirectLocation, nextState) => {})\n * - isActive(pathname, query, indexOnly=false)\n */\n\n\nfunction useRoutes(createHistory) {\n  return function () {\n    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n    var routes = options.routes;\n\n    var historyOptions = _objectWithoutProperties(options, ['routes']);\n\n    var history = _historyLibUseQueries2['default'](createHistory)(historyOptions);\n\n    var state = {};\n\n    function isActive(pathname, query) {\n      var indexOnly = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n      return _isActive3['default'](pathname, query, indexOnly, state.location, state.routes, state.params);\n    }\n\n    function createLocationFromRedirectInfo(_ref) {\n      var pathname = _ref.pathname;\n      var query = _ref.query;\n      var state = _ref.state;\n      return history.createLocation(history.createPath(pathname, query), state, _historyLibActions.REPLACE);\n    }\n\n    var partialNextState = undefined;\n\n    function match(location, callback) {\n      if (partialNextState && partialNextState.location === location) {\n        // Continue from where we left off.\n        finishMatch(partialNextState, callback);\n      } else {\n        _matchRoutes2['default'](routes, location, function (error, nextState) {\n          if (error) {\n            callback(error);\n          } else if (nextState) {\n            finishMatch(_extends({}, nextState, {\n              location: location\n            }), callback);\n          } else {\n            callback();\n          }\n        });\n      }\n    }\n\n    function finishMatch(nextState, callback) {\n      var _computeChangedRoutes = _computeChangedRoutes3['default'](state, nextState);\n\n      var leaveRoutes = _computeChangedRoutes.leaveRoutes;\n      var enterRoutes = _computeChangedRoutes.enterRoutes;\n\n      _TransitionUtils.runLeaveHooks(leaveRoutes);\n\n      _TransitionUtils.runEnterHooks(enterRoutes, nextState, function (error, redirectInfo) {\n        if (error) {\n          callback(error);\n        } else if (redirectInfo) {\n          callback(null, createLocationFromRedirectInfo(redirectInfo));\n        } else {\n          // TODO: Fetch components after state is updated.\n          _getComponents2['default'](nextState, function (error, components) {\n            if (error) {\n              callback(error);\n            } else {\n              // TODO: Make match a pure function and have some other API\n              // for \"match and update state\".\n              callback(null, null, state = _extends({}, nextState, {\n                components: components\n              }));\n            }\n          });\n        }\n      });\n    }\n\n    var RouteGuid = 1;\n\n    function getRouteID(route) {\n      return route.__id__ || (route.__id__ = RouteGuid++);\n    }\n\n    var RouteHooks = {};\n\n    function getRouteHooksForRoutes(routes) {\n      return routes.reduce(function (hooks, route) {\n        hooks.push.apply(hooks, RouteHooks[getRouteID(route)]);\n        return hooks;\n      }, []);\n    }\n\n    function transitionHook(location, callback) {\n      _matchRoutes2['default'](routes, location, function (error, nextState) {\n        if (nextState == null) {\n          // TODO: We didn't actually match anything, but hang\n          // onto error/nextState so we don't have to matchRoutes\n          // again in the listen callback.\n          callback();\n          return;\n        } // Cache some state here so we don't have to\n        // matchRoutes() again in the listen callback.\n\n\n        partialNextState = _extends({}, nextState, {\n          location: location\n        });\n        var hooks = getRouteHooksForRoutes(_computeChangedRoutes3['default'](state, partialNextState).leaveRoutes);\n        var result = undefined;\n\n        for (var i = 0, len = hooks.length; result == null && i < len; ++i) {\n          // Passing the location arg here indicates to\n          // the user that this is a transition hook.\n          result = hooks[i](location);\n        }\n\n        callback(result);\n      });\n    }\n\n    function beforeUnloadHook() {\n      // Synchronously check to see if any route hooks want\n      // to prevent the current window/tab from closing.\n      if (state.routes) {\n        var hooks = getRouteHooksForRoutes(state.routes);\n        var message = undefined;\n\n        for (var i = 0, len = hooks.length; typeof message !== 'string' && i < len; ++i) {\n          // Passing no args indicates to the user that this is a\n          // beforeunload hook. We don't know the next location.\n          message = hooks[i]();\n        }\n\n        return message;\n      }\n    }\n\n    var unlistenBefore = undefined,\n        unlistenBeforeUnload = undefined;\n    /**\n     * Registers the given hook function to run before leaving the given route.\n     *\n     * During a normal transition, the hook function receives the next location\n     * as its only argument and must return either a) a prompt message to show\n     * the user, to make sure they want to leave the page or b) false, to prevent\n     * the transition.\n     *\n     * During the beforeunload event (in browsers) the hook receives no arguments.\n     * In this case it must return a prompt message to prevent the transition.\n     *\n     * Returns a function that may be used to unbind the listener.\n     */\n\n    function listenBeforeLeavingRoute(route, hook) {\n      // TODO: Warn if they register for a route that isn't currently\n      // active. They're probably doing something wrong, like re-creating\n      // route objects on every location change.\n      var routeID = getRouteID(route);\n      var hooks = RouteHooks[routeID];\n\n      if (hooks == null) {\n        var thereWereNoRouteHooks = !hasAnyProperties(RouteHooks);\n        hooks = RouteHooks[routeID] = [hook];\n\n        if (thereWereNoRouteHooks) {\n          // setup transition & beforeunload hooks\n          unlistenBefore = history.listenBefore(transitionHook);\n          if (history.listenBeforeUnload) unlistenBeforeUnload = history.listenBeforeUnload(beforeUnloadHook);\n        }\n      } else if (hooks.indexOf(hook) === -1) {\n        hooks.push(hook);\n      }\n\n      return function () {\n        var hooks = RouteHooks[routeID];\n\n        if (hooks != null) {\n          var newHooks = hooks.filter(function (item) {\n            return item !== hook;\n          });\n\n          if (newHooks.length === 0) {\n            delete RouteHooks[routeID];\n\n            if (!hasAnyProperties(RouteHooks)) {\n              // teardown transition & beforeunload hooks\n              if (unlistenBefore) {\n                unlistenBefore();\n                unlistenBefore = null;\n              }\n\n              if (unlistenBeforeUnload) {\n                unlistenBeforeUnload();\n                unlistenBeforeUnload = null;\n              }\n            }\n          } else {\n            RouteHooks[routeID] = newHooks;\n          }\n        }\n      };\n    }\n    /**\n     * This is the API for stateful environments. As the location\n     * changes, we update state and call the listener. We can also\n     * gracefully handle errors and redirects.\n     */\n\n\n    function listen(listener) {\n      // TODO: Only use a single history listener. Otherwise we'll\n      // end up with multiple concurrent calls to match.\n      return history.listen(function (location) {\n        if (state.location === location) {\n          listener(null, state);\n        } else {\n          match(location, function (error, redirectLocation, nextState) {\n            if (error) {\n              listener(error);\n            } else if (redirectLocation) {\n              history.transitionTo(redirectLocation);\n            } else if (nextState) {\n              listener(null, nextState);\n            } else {\n              process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'Location \"%s\" did not match any routes', location.pathname + location.search + location.hash) : undefined;\n            }\n          });\n        }\n      });\n    }\n\n    return _extends({}, history, {\n      isActive: isActive,\n      match: match,\n      listenBeforeLeavingRoute: listenBeforeLeavingRoute,\n      listen: listen\n    });\n  };\n}\n\nexports['default'] = useRoutes;\nmodule.exports = exports['default'];","map":{"version":3,"names":["exports","__esModule","_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","_interopRequireDefault","obj","_objectWithoutProperties","keys","indexOf","_warning","require","_warning2","_historyLibActions","_historyLibUseQueries","_historyLibUseQueries2","_computeChangedRoutes2","_computeChangedRoutes3","_TransitionUtils","_isActive2","_isActive3","_getComponents","_getComponents2","_matchRoutes","_matchRoutes2","hasAnyProperties","object","p","useRoutes","createHistory","options","undefined","routes","historyOptions","history","state","isActive","pathname","query","indexOnly","location","params","createLocationFromRedirectInfo","_ref","createLocation","createPath","REPLACE","partialNextState","match","callback","finishMatch","error","nextState","_computeChangedRoutes","leaveRoutes","enterRoutes","runLeaveHooks","runEnterHooks","redirectInfo","components","RouteGuid","getRouteID","route","__id__","RouteHooks","getRouteHooksForRoutes","reduce","hooks","push","apply","transitionHook","result","len","beforeUnloadHook","message","unlistenBefore","unlistenBeforeUnload","listenBeforeLeavingRoute","hook","routeID","thereWereNoRouteHooks","listenBefore","listenBeforeUnload","newHooks","filter","item","listen","listener","redirectLocation","transitionTo","process","env","NODE_ENV","search","hash","module"],"sources":["C:/Users/Elite/Desktop/madrasatech/node_modules/react-router/lib/useRoutes.js"],"sourcesContent":["'use strict';\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nvar _warning = require('warning');\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nvar _historyLibActions = require('history/lib/Actions');\n\nvar _historyLibUseQueries = require('history/lib/useQueries');\n\nvar _historyLibUseQueries2 = _interopRequireDefault(_historyLibUseQueries);\n\nvar _computeChangedRoutes2 = require('./computeChangedRoutes');\n\nvar _computeChangedRoutes3 = _interopRequireDefault(_computeChangedRoutes2);\n\nvar _TransitionUtils = require('./TransitionUtils');\n\nvar _isActive2 = require('./isActive');\n\nvar _isActive3 = _interopRequireDefault(_isActive2);\n\nvar _getComponents = require('./getComponents');\n\nvar _getComponents2 = _interopRequireDefault(_getComponents);\n\nvar _matchRoutes = require('./matchRoutes');\n\nvar _matchRoutes2 = _interopRequireDefault(_matchRoutes);\n\nfunction hasAnyProperties(object) {\n  for (var p in object) {\n    if (object.hasOwnProperty(p)) return true;\n  }return false;\n}\n\n/**\n * Returns a new createHistory function that may be used to create\n * history objects that know about routing.\n *\n * Enhances history objects with the following methods:\n *\n * - listen((error, nextState) => {})\n * - listenBeforeLeavingRoute(route, (nextLocation) => {})\n * - match(location, (error, redirectLocation, nextState) => {})\n * - isActive(pathname, query, indexOnly=false)\n */\nfunction useRoutes(createHistory) {\n  return function () {\n    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n    var routes = options.routes;\n\n    var historyOptions = _objectWithoutProperties(options, ['routes']);\n\n    var history = _historyLibUseQueries2['default'](createHistory)(historyOptions);\n    var state = {};\n\n    function isActive(pathname, query) {\n      var indexOnly = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n      return _isActive3['default'](pathname, query, indexOnly, state.location, state.routes, state.params);\n    }\n\n    function createLocationFromRedirectInfo(_ref) {\n      var pathname = _ref.pathname;\n      var query = _ref.query;\n      var state = _ref.state;\n\n      return history.createLocation(history.createPath(pathname, query), state, _historyLibActions.REPLACE);\n    }\n\n    var partialNextState = undefined;\n\n    function match(location, callback) {\n      if (partialNextState && partialNextState.location === location) {\n        // Continue from where we left off.\n        finishMatch(partialNextState, callback);\n      } else {\n        _matchRoutes2['default'](routes, location, function (error, nextState) {\n          if (error) {\n            callback(error);\n          } else if (nextState) {\n            finishMatch(_extends({}, nextState, { location: location }), callback);\n          } else {\n            callback();\n          }\n        });\n      }\n    }\n\n    function finishMatch(nextState, callback) {\n      var _computeChangedRoutes = _computeChangedRoutes3['default'](state, nextState);\n\n      var leaveRoutes = _computeChangedRoutes.leaveRoutes;\n      var enterRoutes = _computeChangedRoutes.enterRoutes;\n\n      _TransitionUtils.runLeaveHooks(leaveRoutes);\n\n      _TransitionUtils.runEnterHooks(enterRoutes, nextState, function (error, redirectInfo) {\n        if (error) {\n          callback(error);\n        } else if (redirectInfo) {\n          callback(null, createLocationFromRedirectInfo(redirectInfo));\n        } else {\n          // TODO: Fetch components after state is updated.\n          _getComponents2['default'](nextState, function (error, components) {\n            if (error) {\n              callback(error);\n            } else {\n              // TODO: Make match a pure function and have some other API\n              // for \"match and update state\".\n              callback(null, null, state = _extends({}, nextState, { components: components }));\n            }\n          });\n        }\n      });\n    }\n\n    var RouteGuid = 1;\n\n    function getRouteID(route) {\n      return route.__id__ || (route.__id__ = RouteGuid++);\n    }\n\n    var RouteHooks = {};\n\n    function getRouteHooksForRoutes(routes) {\n      return routes.reduce(function (hooks, route) {\n        hooks.push.apply(hooks, RouteHooks[getRouteID(route)]);\n        return hooks;\n      }, []);\n    }\n\n    function transitionHook(location, callback) {\n      _matchRoutes2['default'](routes, location, function (error, nextState) {\n        if (nextState == null) {\n          // TODO: We didn't actually match anything, but hang\n          // onto error/nextState so we don't have to matchRoutes\n          // again in the listen callback.\n          callback();\n          return;\n        }\n\n        // Cache some state here so we don't have to\n        // matchRoutes() again in the listen callback.\n        partialNextState = _extends({}, nextState, { location: location });\n\n        var hooks = getRouteHooksForRoutes(_computeChangedRoutes3['default'](state, partialNextState).leaveRoutes);\n\n        var result = undefined;\n        for (var i = 0, len = hooks.length; result == null && i < len; ++i) {\n          // Passing the location arg here indicates to\n          // the user that this is a transition hook.\n          result = hooks[i](location);\n        }\n\n        callback(result);\n      });\n    }\n\n    function beforeUnloadHook() {\n      // Synchronously check to see if any route hooks want\n      // to prevent the current window/tab from closing.\n      if (state.routes) {\n        var hooks = getRouteHooksForRoutes(state.routes);\n\n        var message = undefined;\n        for (var i = 0, len = hooks.length; typeof message !== 'string' && i < len; ++i) {\n          // Passing no args indicates to the user that this is a\n          // beforeunload hook. We don't know the next location.\n          message = hooks[i]();\n        }\n\n        return message;\n      }\n    }\n\n    var unlistenBefore = undefined,\n        unlistenBeforeUnload = undefined;\n\n    /**\n     * Registers the given hook function to run before leaving the given route.\n     *\n     * During a normal transition, the hook function receives the next location\n     * as its only argument and must return either a) a prompt message to show\n     * the user, to make sure they want to leave the page or b) false, to prevent\n     * the transition.\n     *\n     * During the beforeunload event (in browsers) the hook receives no arguments.\n     * In this case it must return a prompt message to prevent the transition.\n     *\n     * Returns a function that may be used to unbind the listener.\n     */\n    function listenBeforeLeavingRoute(route, hook) {\n      // TODO: Warn if they register for a route that isn't currently\n      // active. They're probably doing something wrong, like re-creating\n      // route objects on every location change.\n      var routeID = getRouteID(route);\n      var hooks = RouteHooks[routeID];\n\n      if (hooks == null) {\n        var thereWereNoRouteHooks = !hasAnyProperties(RouteHooks);\n\n        hooks = RouteHooks[routeID] = [hook];\n\n        if (thereWereNoRouteHooks) {\n          // setup transition & beforeunload hooks\n          unlistenBefore = history.listenBefore(transitionHook);\n\n          if (history.listenBeforeUnload) unlistenBeforeUnload = history.listenBeforeUnload(beforeUnloadHook);\n        }\n      } else if (hooks.indexOf(hook) === -1) {\n        hooks.push(hook);\n      }\n\n      return function () {\n        var hooks = RouteHooks[routeID];\n\n        if (hooks != null) {\n          var newHooks = hooks.filter(function (item) {\n            return item !== hook;\n          });\n\n          if (newHooks.length === 0) {\n            delete RouteHooks[routeID];\n\n            if (!hasAnyProperties(RouteHooks)) {\n              // teardown transition & beforeunload hooks\n              if (unlistenBefore) {\n                unlistenBefore();\n                unlistenBefore = null;\n              }\n\n              if (unlistenBeforeUnload) {\n                unlistenBeforeUnload();\n                unlistenBeforeUnload = null;\n              }\n            }\n          } else {\n            RouteHooks[routeID] = newHooks;\n          }\n        }\n      };\n    }\n\n    /**\n     * This is the API for stateful environments. As the location\n     * changes, we update state and call the listener. We can also\n     * gracefully handle errors and redirects.\n     */\n    function listen(listener) {\n      // TODO: Only use a single history listener. Otherwise we'll\n      // end up with multiple concurrent calls to match.\n      return history.listen(function (location) {\n        if (state.location === location) {\n          listener(null, state);\n        } else {\n          match(location, function (error, redirectLocation, nextState) {\n            if (error) {\n              listener(error);\n            } else if (redirectLocation) {\n              history.transitionTo(redirectLocation);\n            } else if (nextState) {\n              listener(null, nextState);\n            } else {\n              process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'Location \"%s\" did not match any routes', location.pathname + location.search + location.hash) : undefined;\n            }\n          });\n        }\n      });\n    }\n\n    return _extends({}, history, {\n      isActive: isActive,\n      match: match,\n      listenBeforeLeavingRoute: listenBeforeLeavingRoute,\n      listen: listen\n    });\n  };\n}\n\nexports['default'] = useRoutes;\nmodule.exports = exports['default'];"],"mappings":"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"},"metadata":{},"sourceType":"script"}